{
  "version": 3,
  "sources": ["src/index.ts", "src/polyfills.ts", "src/vdom/h.ts", "src/vdom/diff.ts", "src/vdom/utils.ts", "src/vdom/render.ts", "src/vdom/fn.ts", "src/vdom/component.ts", "src/tag/registry.ts", "src/tag/factory.ts"],
  "sourcesContent": ["import \"./polyfills\";\r\nexport { h, Fragment } from \"./vdom/h\";\r\nexport { render } from \"./vdom/render\";\r\nexport { getDOMNode, unmountComponent, createRef, Ref } from \"./vdom/fn\";\r\nexport { Component } from \"./vdom/component\";\r\nimport \"./tag/registry\";\r\nexport { Tag } from \"./tag/factory\";\r\nexport { TagRegistry } from \"./tag/registry\";\r\nexport { VElement } from \"./vdom/component\";\r\n", "/* eslint-disable */\r\n/*istanbul ignore next */\r\n(() => {\r\n  if (\"NodeList\" in window && !NodeList.prototype.forEach) {\r\n    console.info(\"Loaded NodeList.prototype.forEach Polyfill\");\r\n    NodeList.prototype.forEach = function(callback, thisArg) {\r\n      thisArg = thisArg || window;\r\n      for (var i = 0; i < this.length; i++) {\r\n        callback.call(thisArg, this[i], i, this);\r\n      }\r\n    };\r\n  }\r\n})();\r\n", "import { Component, VElement, PropsOrState } from \"./component\";\r\ntype h = {\r\n  (type: string, props: object, ...children: any[]);\r\n  (type: Function, props: object, ...children: any[]);\r\n  (type: Component<any, any>, props: object, ...children: any[]);\r\n};\r\ntype RawComponent = {\r\n  [index: number]: {\r\n    type: Component<any, any>;\r\n    props: PropsOrState;\r\n  };\r\n};\r\n/**\r\n * The hyperscript function which will create virtual elements.\r\n * @param type Can be the tagname of the element, a class component or a functional component\r\n * @param props Properties to be passed\r\n * @param children Child elements, if any\r\n * Usage:\r\n * ```js\r\n * let app = h(\"div\", null, h(\"h1\", null, \"Hello\"))\r\n * //becomes\r\n * //<div><h1>Hello</h1></div>\r\n * ```\r\n */\r\nexport const h: h = (type: any, props: object, ...children: any[]) => {\r\n  props = !props ? {} : props;\r\n  if (type.prototype && type.prototype.isClassComponent) {\r\n    const rawComponent: RawComponent = [type, { ...props, children }];\r\n    return rawComponent;\r\n  }\r\n  if (typeof type === \"function\") {\r\n    const func = type({ ...props, children });\r\n    return func;\r\n  }\r\n  const node: VElement = { type, props: { ...props, children } };\r\n  return node;\r\n};\r\n\r\nexport const Fragment = props => {\r\n  props.children.unshift(\"__FRAGMENT__\");\r\n  return props.children;\r\n};\r\n", "import { renderEl } from \"./render\";\r\nimport { HConstructorElement, VElement } from \"./component\";\r\n/*istanbul ignore next */\r\nconst checkAttrs = (a: NamedNodeMap, b: NamedNodeMap): boolean => {\r\n  if (!a || !b) return;\r\n  let c = \"\";\r\n  Array.prototype.slice.call(a).map(x => {\r\n    c = c + x.toString();\r\n  });\r\n  let d = \"\";\r\n  Array.prototype.slice.call(b).map(x => {\r\n    d = d + x.toString();\r\n  });\r\n  return c === d;\r\n};\r\n//Ignoring temporarily cause tests not ready\r\n/* istanbul ignore next */\r\nconst diffChildren = (\r\n  child: Element,\r\n  el: Element,\r\n  sameKind?: boolean\r\n): void => {\r\n  if (\r\n    //is a text node\r\n    child.nodeType === 3\r\n  ) {\r\n    if (child.nodeValue !== el.nodeValue) {\r\n      child.nodeValue = el.nodeValue;\r\n    }\r\n  }\r\n  outer: if (\r\n    //same tag or is a fragment\r\n    child.nodeName === el.nodeName &&\r\n    //same attributes\r\n    checkAttrs(child.attributes, el.attributes) &&\r\n    //is a element\r\n    child.nodeType === 1\r\n  ) {\r\n    for (let i = 0; i < child.childNodes.length; i++) {\r\n      const elc: ChildNode = el.childNodes[i];\r\n      const cc: ChildNode = child.childNodes[i];\r\n      //if childnodes length differs\r\n      if (child.childNodes.length < el.childNodes.length) {\r\n        for (let i = child.childNodes.length; i < el.childNodes.length; i++) {\r\n          //append the missing child\r\n          child.appendChild(el.childNodes[i]);\r\n        }\r\n        //and break the loop for further check\r\n        break outer;\r\n      }\r\n      if (child.childNodes.length > el.childNodes.length) {\r\n        //if same kind of nodes and first one is ahead then break\r\n        if (sameKind) {\r\n          break outer;\r\n        }\r\n        //else replace the child\r\n        child.parentElement.replaceChild(el, child);\r\n        //and break the loop for further check\r\n        break outer;\r\n      }\r\n      if (elc.firstChild && cc.firstChild) {\r\n        //if innerHTML(nodeValue) not equal, replace it\r\n        if (elc.firstChild.nodeValue !== cc.firstChild.nodeValue) {\r\n          cc.firstChild.nodeValue = elc.firstChild.nodeValue;\r\n        }\r\n      } else {\r\n        //if innerHTML(nodeValue) not equal, replace it\r\n        if (elc.nodeValue !== cc.nodeValue) {\r\n          cc.nodeValue = elc.nodeValue;\r\n        }\r\n      }\r\n    }\r\n  }\r\n  //if child and el has\r\n  if (\r\n    //same tag\r\n    child.nodeName === el.nodeName &&\r\n    //but not same attributes\r\n    !checkAttrs(child.attributes, el.attributes) &&\r\n    //is a element\r\n    child.nodeType === 1\r\n  ) {\r\n    //remove old attributes\r\n    while (child.attributes.length > 0)\r\n      child.removeAttribute(child.attributes[0].name);\r\n    //add new attributes\r\n    Array.prototype.slice.call(el.attributes).forEach((e: Attr) => {\r\n      child.setAttribute(e.name, e.value);\r\n    });\r\n  }\r\n};\r\n//Ignoring temporarily cause tests not ready\r\n/* istanbul ignore next */\r\nexport const diff = (\r\n  dom: any,\r\n  node: VElement,\r\n  diffType: string,\r\n  isDirty: boolean\r\n) => {\r\n  //if reconciliation is for updating, start\r\n  if (diffType === \"UPDATE\") {\r\n    let sameKind: boolean;\r\n    let el: Element = renderEl(node, undefined, false);\r\n    //due to an unknown issue, a RawComponent may have crept here as the new DOM,\r\n    // so further check\r\n    if (Array.isArray(el)) {\r\n      //if we're re-diffing same node when render is called twice\r\n      sameKind = dom[\"__tdNode__\"]\r\n        ? dom[\"__tdNode__\"].toString() === el[1].toString()\r\n        : false;\r\n      //extract the dom\r\n      el = el[0];\r\n    }\r\n    //lookup further if dom has only one child\r\n    if (dom.childElementCount === 1) {\r\n      dom.childNodes.forEach((child: Element) => {\r\n        if (child.nodeName === el.nodeName && child.innerHTML !== el.innerHTML)\r\n          diffChildren(child, el, sameKind);\r\n      });\r\n    } else if (\r\n      // is documentFragment\r\n      dom.childElementCount > 1 &&\r\n      el.nodeName === \"#document-fragment\"\r\n    ) {\r\n      dom.childNodes.forEach((child: Element, index: number) => {\r\n        const elchild: any = el.childNodes[index];\r\n        diffChildren(child, elchild, sameKind);\r\n      });\r\n      node.dom = dom;\r\n    } else {\r\n      {\r\n        //lookup further in all children\r\n        const domChildren: NodeListOf<ChildNode> = dom.childNodes;\r\n        domChildren.forEach((child: Element, index: number) => {\r\n          if (\r\n            child.nodeName === el.nodeName &&\r\n            child.innerHTML !== el.innerHTML\r\n          ) {\r\n            diffChildren(child, el, sameKind);\r\n            node.dom = child;\r\n          }\r\n        });\r\n      }\r\n    }\r\n    return dom;\r\n  } else if (diffType === \"PLACEMENT\") {\r\n    //if dom not present, render the element.\r\n    const el = renderEl(node, dom, true);\r\n    //if its component, get the first el which contains the dom\r\n    let newDOM = Array.isArray(el) ? el[0] : el;\r\n    //get the component, if present\r\n    let c: HConstructorElement = el[1];\r\n    //due to an unknown issue, a RawComponent may have crept here as the new DOM, so further check\r\n    if (Array.isArray(newDOM)) {\r\n      //extract the dom\r\n      newDOM = newDOM[0];\r\n      c = newDOM[1];\r\n    }\r\n    //add simple Component 'metadaata' to DOM parent\r\n    dom[\"__tdNode__\"] = node;\r\n    //add class Component 'metadata' to the DOM parent\r\n    if (el[1]) {\r\n      dom[\"__tdNode__\"] = el[1];\r\n    }\r\n    if (c && c.componentWillMount && isDirty) {\r\n      c.componentWillMount(newDOM);\r\n    }\r\n    dom.appendChild(newDOM);\r\n    if (c && c.componentDidMount && isDirty) {\r\n      c.componentDidMount(newDOM);\r\n    }\r\n    return newDOM;\r\n  }\r\n};\r\n", "/**\n * Assign styles to a element\n * @param el any HTMLElement\n * @param styles CSSStyleDeclaration object\n */\n\n/*istanbul ignore next : no need to test this, just a util function */\nconst assignStyles = (el: HTMLElement, styles: CSSStyleDeclaration) => {\n  for (const rule in styles) {\n    el.style[rule] = styles[rule];\n  }\n};\n/**\n * Parse JSX props and return it\n * @param props `Object.keys(yourProps)`\n * @param dom the element\n */\nexport const parseProps = (props: object, dom: HTMLElement) => {\n  const keys = Object.keys(props);\n  const isRef = (key: string) => {\n    return key === \"ref\";\n  };\n  const isSpecialProp = (key: string) => {\n    const specialProps = [\"innerHTML\", \"className\", \"style\"];\n    return specialProps.indexOf(key) > -1;\n  };\n  const isEvent = (key: string) => {\n    return key.indexOf(\"on\") === 0;\n  };\n  const isProp = (key: string) => {\n    return (\n      key !== \"children\" && !isEvent(key) && !isSpecialProp(key) && !isRef(key)\n    );\n  };\n  keys.filter(isRef).forEach((ref: string) => {\n    props[ref].element = dom;\n  });\n  keys.filter(isEvent).forEach(event => {\n    const type = event.substring(2).toLowerCase();\n    dom.addEventListener(type, props[event]);\n  });\n  keys.filter(isProp).map(prop => {\n    dom.setAttribute(prop, props[prop].toString());\n  });\n  keys.filter(isSpecialProp).map(prop => {\n    if (prop === \"style\") {\n      if (typeof props[prop] === \"string\") {\n        dom.style.cssText = props[prop];\n      } else assignStyles(dom, props[prop]);\n    } else dom[prop] = props[prop];\n  });\n};\n", "import { diff } from \"./diff\";\r\nimport { HConstructorElement, VElement } from \"./component\";\r\nimport { parseProps } from \"./utils\";\r\n/**\r\n * The runtime condition of a Constructor Element\r\n */\r\ninterface HElementRuntime {\r\n  (component: HConstructorElement);\r\n  (component: any);\r\n}\r\n/* istanbul ignore next */\r\n//Ignoring this cause this does not need testing anyway\r\nexport const renderComponent: HElementRuntime = (\r\n  component: HConstructorElement\r\n): void => {\r\n  //only proceed if the component has mounted, else return\r\n  if (component.base && component.dom) {\r\n    const rerendered: VElement = component.render();\r\n    const base: string[] = [];\r\n    base.push(component.base.innerHTML);\r\n    const oldDom = component.dom;\r\n    component.base = diff(component.base, rerendered, \"UPDATE\", false);\r\n    base.push(component.base.innerHTML);\r\n    if (base[0] !== base[1]) {\r\n      component.componentDidUpdate(oldDom, component.dom);\r\n    }\r\n  } else return;\r\n};\r\nexport const cleanRender = (\r\n  node: VElement,\r\n  target: Element | DocumentFragment\r\n) => {\r\n  diff(target, node, \"PLACEMENT\", true);\r\n};\r\n/**\r\n * Another version of render, but will only be used in the process of updating.\r\n * @param node Your virtual Element\r\n * @param target The target to append to\r\n */\r\nconst updateRender = (node: VElement, target: Element | DocumentFragment) => {\r\n  diff(target, node, \"PLACEMENT\", false);\r\n};\r\n/**\r\n * Assign styles to a element\r\n * @param el any HTMLElement\r\n * @param styles CSSStyleDeclaration object\r\n */\r\n/*istanbul ignore next : no need to test this, just a util function */\r\nconst assignStyles = (el: HTMLElement, styles: CSSStyleDeclaration) => {\r\n  for (const rule in styles) {\r\n    el.style[rule] = styles[rule];\r\n  }\r\n};\r\n/**\r\n * Return DOM based on JSX Elements\r\n * @param node The JSX element\r\n * @param target Target to mount to\r\n * @param isDirty if dirty(rendering for the first time)\r\n */\r\nexport const renderEl = (node: any, target?: any, isDirty?: boolean) => {\r\n  const textTypes = [\"string\", \"number\", \"boolean\"];\r\n  /* istanbul ignore if*/ if (textTypes.indexOf(typeof node) > -1) {\r\n    return document.createTextNode(node);\r\n  }\r\n  if (Array.isArray(node)) {\r\n    /*istanbul ignore next: probably not picked up by istanbul */\r\n    if (node[0] === \"__FRAGMENT__\") {\r\n      const fragDom: DocumentFragment = document.createDocumentFragment();\r\n      node.shift();\r\n      node.forEach(child => {\r\n        if (isDirty) {\r\n          cleanRender(child, fragDom);\r\n        } else {\r\n          updateRender(child, fragDom);\r\n        }\r\n      });\r\n      return fragDom;\r\n    } else {\r\n      const app = node[0],\r\n        props: object = node[1];\r\n      const component: HConstructorElement = new app(props);\r\n      component.node = component.render();\r\n      component.base = target;\r\n      const dom = renderEl(component.node, undefined, true);\r\n      component.dom = dom;\r\n      return [dom, component];\r\n    }\r\n  } else {\r\n    const dom: HTMLElement = document.createElement(node.type);\r\n    parseProps(node.props, dom);\r\n    node.props.children.forEach(child => {\r\n      if (textTypes.indexOf(typeof child) > -1)\r\n        dom.appendChild(document.createTextNode(child));\r\n      else {\r\n        /*istanbul ignore next: probably not picked up by istanbul */ if (\r\n          isDirty\r\n        )\r\n          cleanRender(child, dom);\r\n        /*istanbul ignore next: probably not picked up by istanbul */ else\r\n          updateRender(child, dom);\r\n      }\r\n    });\r\n    //set dom for future reference\r\n    node.dom = dom;\r\n    node.base = target;\r\n    return dom;\r\n  }\r\n};\r\n/**\r\n * The function that links your Virtual Elements to the real DOM.\r\n * Appends the virtual element to the target\r\n * Usage:\r\n * ```js\r\n * //App is a Component\r\n * //If JSX\r\n * render(<App />, document.querySelector(\"#app\"))\r\n * //If no JSX\r\n * render(h(App, null), document.querySelector(\"#app\"))\r\n * ```\r\n * @param node Your virtual Element\r\n * @param target The target to append to\r\n */\r\nexport const render = (node: VElement, target: Element) => {\r\n  /*istanbul ignore next */\r\n  if (target[\"__tdNode__\"]) {\r\n    diff(target, node, \"UPDATE\", true);\r\n  } else diff(target, node, \"PLACEMENT\", true);\r\n};\r\n", "import { Component, VElement } from \"./component\";\r\n\r\n/**\r\n * Get the rendered DOM of the Component\r\n * Only use this when the component is rendered (componentDidMount is a good place to use this)\r\n * @param component The component to get the node\r\n */\r\nexport const getDOMNode = (component: Component | VElement): Element => {\r\n  return component.dom;\r\n};\r\n\r\n/**\r\n * Unmount a class Component from the DOM\r\n * @param dom The parent element of the Component\r\n * @param component The component class to unmount\r\n */\r\nexport const unmountComponent = (dom: Element): boolean => {\r\n  const HNode: Component = dom[\"__tdNode__\"];\r\n  if (!HNode) return false;\r\n  //Taking strings as evaluation becomes easier and to avoid TS-2367 error\r\n  HNode.base.removeChild(HNode.dom);\r\n  // #6\r\n  dom[\"__tdNode__\"] = undefined;\r\n  if (HNode.componentDidUnmount) HNode.componentDidUnmount();\r\n  return true;\r\n};\r\n\r\n/**\r\n * Create a ref (reference to a DOM element)\r\n */\r\nexport const createRef = () => {\r\n  const ref: Ref = {\r\n    element: null,\r\n  };\r\n  return ref;\r\n};\r\n/**\r\n * Standard interface of a ref\r\n */\r\nexport interface Ref {\r\n  /**\r\n   * The element stored in ref\r\n   */\r\n  element: Element | null;\r\n}\r\n", "/* eslint @typescript-eslint/no-unused-vars : 0 */\r\n/* eslint @typescript-eslint/no-empty-function: 0 */\r\nimport { renderComponent } from \"./render\";\r\n/*istanbul ignore next */\r\n/**\r\n * The class used for the instantaniation of TeddyTags virtual elements\r\n *\r\n * Declaration:\r\n * ```js\r\n * class MyComponent extends Component{\r\n *  constructor(props){\r\n *    super(props)\r\n *  }\r\n *  render(){\r\n *    //return your markup\r\n *  }\r\n * }\r\n * ```\r\n */\r\n/*istanbul ignore next */\r\nexport class Component<P extends object = any, S extends object = any>\r\n  implements ComponentFunctions {\r\n  /**\r\n   * The general properties of the Component. Cannot be changed once set.\r\n   * Should contain some unique or permanent information.\r\n   * Only accessible if passed through the constructor as `super(props)`.\r\n   */\r\n  readonly props: P;\r\n  /**\r\n   * The attributes of the Component which can be changed as per user's basis.\r\n   * Should contain some temporary information.\r\n   */\r\n  state: S;\r\n  /**\r\n   * The constructor of the Component. It is a **must to pass `super(props)`** before other things.\r\n   * @param {P} props The properties of the Component\r\n   */\r\n  constructor(props: P) {\r\n    this.props = props;\r\n  }\r\n  /**\r\n   * The function which will alter with the `state` property of the Component.\r\n   * @param state\r\n   */\r\n  /* istanbul ignore next */\r\n  setState(state: S): void {\r\n    this.state = Object.create(state);\r\n    renderComponent(this);\r\n  }\r\n  readonly node?: VElement;\r\n  base?: Element;\r\n  dom?: Element;\r\n  render(): any {}\r\n  componentDidMount(dom?: Element) {}\r\n  componentDidUnmount() {}\r\n  componentDidUpdate(oldDOM?: Element, newDOM?: Element) {}\r\n  componentWillMount(dom?: Element) {}\r\n}\r\nComponent.prototype[\"isClassComponent\"] = true;\r\n/**\r\n * The standard interface of an non-component virtual element\r\n */\r\nexport interface VElement {\r\n  type: string;\r\n  dom?: Element;\r\n  readonly props: PropsOrState;\r\n  [children: string]: any;\r\n}\r\nexport type PropsOrState<T = any> = { [propOrState: string]: T };\r\n/**\r\n * The standard interface of a component virtual element\r\n */\r\nexport interface HConstructorElement<P = any, S = any>\r\n  extends ComponentFunctions {\r\n  readonly props: PropsOrState<P>;\r\n  state: PropsOrState<S>;\r\n  new (props: PropsOrState<P>): void;\r\n  node?: VElement;\r\n  base?: Element;\r\n  dom?: Element;\r\n}\r\ninterface ComponentFunctions {\r\n  /**\r\n   * The function which will return the general markup of the Component.\r\n   * For Component to appear in the DOM, this function is necessary.\r\n   */\r\n  render(): VElement;\r\n  /**\r\n   * The function which will invoke when the component is about to mount.\r\n   * @param dom The DOM element that will be mounted\r\n   */\r\n  componentWillMount(dom?: Element): void;\r\n  /**\r\n   * The function which will invoke immediately after mounting the component.\r\n   * @param dom The DOM element that will is mounted\r\n   */\r\n  componentDidMount(dom?: Element): void;\r\n  /**\r\n   * The function which will invoke immediately if the DOM of component updates.\r\n   * @param oldDOM The old DOM element\r\n   * @param newDOM The updated DOM element\r\n   */\r\n  componentDidUpdate(oldDOM?: Element, newDOM?: Element): void;\r\n  /**\r\n   * The function which will invoke immediately after unmounting the component.\r\n   */\r\n  componentDidUnmount(): void;\r\n}\r\n", "import { Component } from \"../vdom/component\";\r\ndeclare global {\r\n  interface Window {\r\n    /**\r\n     * The TeddyTags Custom Tag registry instance\r\n     */\r\n    TagRegistry: TagRegistry;\r\n    /**\r\n     * Global flag to check if observing the DOM\r\n     */\r\n    __TD_DOM_OBSERVER__: boolean;\r\n    WebKitMutationObserver: typeof MutationObserver;\r\n    MozMutationObserver: typeof MutationObserver;\r\n  }\r\n  interface HTMLElement {\r\n    /**\r\n     * Information of the custom element\r\n     */\r\n    tag: {\r\n      /**\r\n       * Original custom tag name\r\n       */\r\n      originalName: string;\r\n      /**\r\n       * Tag convertee\r\n       */\r\n      from: string | typeof Component;\r\n    };\r\n  }\r\n}\r\n/**\r\n * The TeddyTags Custom Tag registry instance\r\n */\r\nexport interface TagRegistry {\r\n  /**\r\n   * Registry of all custom elements\r\n   */\r\n  elements: {\r\n    [element: string]: TagRegistryElement;\r\n  };\r\n  /**\r\n   * Get entry from the TagRegistry\r\n   * @param name The entry name\r\n   */\r\n  getEntry(name: string): TagRegistryElement;\r\n  /**\r\n   * Get the mutated nodes\r\n   * @param name The original custom tag name\r\n   */\r\n  getNodes(name: string): HTMLElement[];\r\n}\r\n/**\r\n * An entry of a custom element in the TagRegistry\r\n */\r\nexport interface TagRegistryElement {\r\n  /**\r\n   * Form to which are converted to\r\n   */\r\n  from: string | typeof Component;\r\n  /**\r\n   * An array of converted custom elements\r\n   */\r\n  nodes: Array<HTMLElement>;\r\n}\r\n\r\nconst getEntry = (name: string): TagRegistryElement => {\r\n  const requiredTag = window.TagRegistry.elements[name];\r\n  return requiredTag;\r\n};\r\nconst getNodes = (name: string): HTMLElement[] => {\r\n  const nodes = getEntry(name).nodes;\r\n  return nodes;\r\n};\r\nwindow.TagRegistry = { elements: {}, getEntry, getNodes };\r\n", "import { Component } from \"../vdom/component\";\nimport { h } from \"../vdom/h\";\nimport { render } from \"../vdom/render\";\nimport { TagRegistryElement } from \"./registry\";\n\ninterface TagConstructorOptions {\n  /**\n   * Tag name of the custom element\n   */\n  name: string;\n  /**\n   * Tag name of a vaild native HTML5 element or a TeddyTags class Component\n   */\n  to: string | typeof Component;\n}\n/**\n * Record an entry in the registry\n * @param name The name of the new entry\n * @param entry The entry to be recorded\n */\nconst setInRegistry = (name: string, entry: TagRegistryElement): void => {\n  window.TagRegistry.elements[name] = entry;\n};\n/**\n * Update an existing entry in the registry\n * @param name Name of existing registry\n * @param newEntry The new entry to be updated\n */\nconst updateInRegistry = (name: string, newEntry: TagRegistryElement): void => {\n  const originalNodes = window.TagRegistry.getNodes(name);\n  const newNodes = newEntry.nodes.splice(originalNodes.length - 1);\n  window.TagRegistry.elements[name].nodes = window.TagRegistry.getNodes(\n    name\n  ).concat(newNodes);\n};\n/**\n * Transform custom elements to the desired ones\n * @param tagName name of the custom element\n * @param newTagName a valid HTML5 tag or any tag name\n */\nconst transformElements = (tagName: string, newTagName: string) => {\n  const registryEntry: TagRegistryElement = { from: newTagName, nodes: [] };\n  const nodes = document.querySelectorAll(tagName);\n  nodes.forEach(node => {\n    const newNode = document.createElement(newTagName);\n    newNode.tag = {\n      originalName: tagName,\n      from: newTagName,\n    };\n    Array.prototype.slice.call(node.attributes).forEach((attr: Attr) => {\n      newNode.setAttribute(attr.name, attr.value);\n    });\n    newNode.nodeValue = node.nodeValue;\n    node.parentElement.replaceChild(newNode, node);\n    registryEntry.nodes.push(newNode);\n  });\n  return registryEntry;\n};\n/**\n * Transform an custom element with a class Component\n * @param tagName name of the custom element\n * @param component a TeddyTags class Component\n */\nconst transformElementsWithComponents = (\n  tagName: string,\n  component: typeof Component\n) => {\n  const registry = transformElements(tagName, \"div\");\n  registry.from = component;\n  registry.nodes.forEach(node => {\n    node.tag.from = component;\n    const getComponentName = () =>\n      //directly class/fn name\n      component.name ||\n      // Nasty IE hack: element tag name\n      tagName;\n    node.setAttribute(\"data-component\", getComponentName());\n    const props = {};\n    Array.prototype.slice.call(node.attributes).forEach((a: Attr) => {\n      props[a.name] = a.value;\n    });\n    render(h(component, props), node);\n  });\n  return registry;\n};\n/**\n * Update a custom element to the desired one(existing in the registry)\n * @param tagName name of the custom element\n * @param to either a tag name or a class Component\n */\nconst updateElement = (tagName: string, to: string | typeof Component) => {\n  if (typeof to === \"string\") {\n    const registry = transformElements(tagName, to);\n    if (window.TagRegistry.elements[tagName])\n      updateInRegistry(tagName, registry);\n  } else {\n    const registry = transformElementsWithComponents(tagName, to);\n    if (window.TagRegistry.elements[tagName])\n      updateInRegistry(tagName, registry);\n  }\n};\n/**\n * Initialize the DOM watcher to update newly added custom elements\n */\nconst initWatcher = () => {\n  const target = document.body;\n  const options: MutationObserverInit = { childList: true, subtree: true };\n  const callback: MutationCallback = (mutations: MutationRecord[]): void => {\n    mutations.forEach(mutation => {\n      if (mutation.type === \"childList\") {\n        mutation.addedNodes.forEach(node => {\n          const registeredTags: string[] = Object.keys(\n            window.TagRegistry.elements\n          );\n          if (node.nodeType === 1) {\n            registeredTags.forEach(tag => {\n              if ((tag.toUpperCase(), node.nodeName)) {\n                updateElement(tag, window.TagRegistry.elements[tag].from);\n              }\n            });\n          }\n        });\n      }\n    });\n  };\n  const MutationObserver =\n    window.MutationObserver ||\n    window.WebKitMutationObserver ||\n    window.MozMutationObserver;\n  const observer = new MutationObserver(callback);\n  observer.observe(target, options);\n  window.__TD_DOM_OBSERVER__ = true;\n};\n\n/**\n * Create amazing custom elements using this class\n */\nexport class Tag {\n  /**\n   * Original tag name\n   */\n  originalName: string;\n  /**\n   * Current tag name or a class Component\n   */\n  current: string | typeof Component;\n  /**\n   * Array of converted custom elements\n   */\n  DOMList: Array<HTMLElement>;\n  /**\n   * Initialize the transformer\n   * @param { TagConstructorOptions } options  Options to pass to the transformer\n   */\n  constructor(options: TagConstructorOptions) {\n    this.originalName = options.name;\n    this.current = options.to;\n    if (typeof options.to === \"string\") {\n      const registry = transformElements(options.name, options.to);\n      setInRegistry(options.name, registry);\n    } else {\n      const registry = transformElementsWithComponents(\n        options.name,\n        options.to\n      );\n      setInRegistry(options.name, registry);\n    }\n    this.DOMList = window.TagRegistry.getNodes(this.originalName);\n    if (window.__TD_DOM_OBSERVER__ !== true) {\n      initWatcher();\n    }\n  }\n}\n"],
  "mappings": "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",
  "names": []
}
